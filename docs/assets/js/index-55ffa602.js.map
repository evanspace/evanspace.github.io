{"version":3,"file":"index-55ffa602.js","sources":["../../../code/src/pages/webgl/effect/shader-over/methods.ts","../../../code/src/pages/webgl/effect/shader-over/index.vue"],"sourcesContent":["import * as THREE from 'three'\nimport { gsap } from 'gsap'\nimport * as ThreeScene from 'three-scene'\n\nconst base = import.meta.env.VITE_BEFORE_STATIC_PATH\n\nconst textureLoader = new THREE.TextureLoader()\n\nconst imgs = ['01.jpeg', '02.jpeg', '03.jpg'].map(it => `${base}/oss/textures/effect/${it}`)\n\nconst loadImg = (): Promise<any[]> => {\n  return new Promise(resolve => {\n    const len = imgs.length\n    const textures = new Array(len)\n    imgs.forEach((src, index) => {\n      textureLoader.load(src, texture => {\n        textures[index] = texture\n        if (textures.filter(Boolean).length === len) {\n          resolve(textures)\n        }\n      })\n    })\n  })\n}\n\nexport class NewThreeScene extends ThreeScene.Scene {\n  textures: InstanceType<typeof THREE.TextureLoader>[] = []\n  material?: InstanceType<typeof THREE.ShaderMaterial>\n\n  isPlaying: boolean = false\n  time: number = 0\n  move: number = 0\n  activeIndex: number = 0\n\n  progress: number = 0\n  isComplete: boolean = true\n\n  constructor(options: ConstructorParameters<typeof ThreeScene.Scene>[0]) {\n    super(options)\n\n    return this\n  }\n\n  async initModel() {\n    this.textures = await loadImg()\n\n    this.addMesh()\n\n    this.play()\n    this.change()\n  }\n\n  addMesh() {\n    const geo = new THREE.PlaneGeometry(1920, 1280)\n    const mat = new THREE.ShaderMaterial({\n      fragmentShader: `\n        varying vec2 vUv;\n        varying vec2 vPosition;\n\n        uniform float time;\n        uniform float progress;\n        uniform vec4 resolution;\n        uniform sampler2D t1;\n        uniform sampler2D t2;\n\n        void main(){\n          vec2 newUV=vec2(vUv-vec2(0.5))*resolution.zw+vec2(.5);\n          vec4 tt1=texture2D(t1,newUV);\n          vec4 tt2=texture2D(t2,newUV);\n          float dist=distance(tt1,tt2)*.5;\n          // dist = newUV.x / 2. + .03 * sin(newUV.y*10. + time* 10.) + 0.2;\n          float pr=step(dist,progress);\n          vec4 final=mix(mix(tt1,tt2,pr),tt2,pr);\n          gl_FragColor=final;\n        }\n      `,\n      vertexShader: `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n      `,\n      uniforms: {\n        progress: {\n          value: 0\n        },\n        time: {\n          value: 0\n        },\n        resolution: {\n          value: new THREE.Vector4()\n        },\n        t1: {\n          value: this.textures[0]\n        },\n        t2: {\n          value: this.textures[1]\n        }\n      },\n      side: THREE.DoubleSide,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      wireframe: false\n    })\n\n    const mesh = new THREE.Mesh(geo, mat)\n    // mesh.rotation.x = -Math.PI * 0.5\n    this.material = mat\n    this.addObject(mesh)\n\n    this.setTextureSize()\n  }\n\n  setTextureSize() {\n    if (!this.material) return\n    const imageAspect = 1280 / 1920\n    const { width, height } = this.options\n    let a1, a2\n    if (height / width > imageAspect) {\n      a1 = (width / height) * imageAspect\n      a2 = 1\n    } else {\n      a1 = 1\n      a2 = height / width / imageAspect\n    }\n\n    this.material.uniforms.resolution.value.x = width\n    this.material.uniforms.resolution.value.y = height\n    this.material.uniforms.resolution.value.z = a1\n    this.material.uniforms.resolution.value.w = a2\n  }\n\n  change() {\n    if (!this.material) return\n    if (!this.isComplete) return\n\n    this.isComplete = false\n    this.material.uniforms.t1.value = this.textures[this.activeIndex++]\n    this.activeIndex %= this.textures.length\n    this.material.uniforms.t2.value = this.textures[this.activeIndex]\n\n    gsap.fromTo(\n      this,\n      {\n        progress: 0\n      },\n      {\n        duration: 2.1,\n        delay: 1.2,\n        progress: 1,\n        onComplete: () => {\n          this.isComplete = true\n          this.change()\n        }\n      }\n    )\n  }\n  play() {\n    if (this.isPlaying) return\n    this.isPlaying = true\n  }\n  stop() {\n    this.isPlaying = false\n  }\n\n  modelAnimate() {\n    if (!this.isPlaying) return\n    this.time += 0.01\n    if (this.material) {\n      this.material.uniforms.time.value = this.time\n      this.material.uniforms.progress.value = this.progress\n    }\n  }\n}\n\n// 顶点颜色\nconst fragmentShader = `\n  varying vec2 vUv;\n  varying vec3 vNormal;\n\n  uniform float time;\n\n  void main(){\n    gl_FragColor=vec4(vUv,0.,1.);\n  }\n`\n\nconst vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`\nconsole.log(fragmentShader, vertexShader)\n","<template>\n  <div :class=\"$style.page\">\n    <div :class=\"$style.container\" ref=\"containerRef\"></div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { NewThreeScene } from './methods'\n// import { Sketch } from './test'\n\nimport { useResize } from '@/hooks/scene-resize'\n\nconst containerRef = ref()\nconst options: ConstructorParameters<typeof NewThreeScene>[0] = {\n  axes: {\n    visible: true\n  },\n  render: {\n    alpha: true\n  },\n  bgColor: void 0,\n  camera: {\n    position: [2000, 0, 2500]\n  },\n  controls: {\n    // visible: false\n    maxDistance: 10000\n  },\n  directionalLight: {\n    visible: false\n  },\n  ambientLight: {\n    visible: false\n  },\n  grid: {\n    visible: true\n  }\n}\nlet scene: InstanceType<typeof NewThreeScene>\n\nonMounted(() => {\n  options.container = containerRef.value\n  // new Sketch({\n  //   el: containerRef.value\n  // })\n  // return\n  scene = new NewThreeScene(options)\n  scene.run()\n\n  useResize(scene).resize()\n})\n</script>\n\n<style lang=\"scss\" module>\n@import './style.scss';\n</style>\n"],"names":["textureLoader","THREE.TextureLoader","imgs","map","it","NewThreeScene","ThreeScene.Scene","constructor","options","super","__publicField","this","initModel","textures","Promise","resolve","len","length","Array","forEach","src","index","load","texture","filter","Boolean","addMesh","play","change","geo","THREE.PlaneGeometry","mat","THREE.ShaderMaterial","fragmentShader","vertexShader","uniforms","progress","value","time","resolution","THREE.Vector4","t1","t2","side","THREE.DoubleSide","transparent","depthTest","depthWrite","wireframe","mesh","THREE.Mesh","material","addObject","setTextureSize","imageAspect","width","height","a1","a2","x","y","z","w","isComplete","activeIndex","gsapWithCSS","fromTo","duration","delay","onComplete","isPlaying","stop","modelAnimate","console","log","containerRef","ref","axes","visible","render","alpha","bgColor","camera","position","controls","maxDistance","directionalLight","ambientLight","grid","scene","onMounted","container","run","useResize","resize"],"mappings":"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"}