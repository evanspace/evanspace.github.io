var e=Object.defineProperty,t=(t,i,s)=>(((t,i,s)=>{i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s})(t,"symbol"!=typeof i?i+"":i,s),s);import{ev as i,dB as s,en as n,ew as a,ex as r,ey as o,ez as l,eA as c,bp as d,bc as h,ba as u,eB as p,bk as m,bd as f,bb as x,dC as y,eo as b,e as g,i as B,l as w,o as v,g as C,h as P}from"./vendor-b6dae1be.js";import{m as T,u as I}from"./scene-resize-2eff274d.js";import"./index-dff0b06d.js";const M=b,R=()=>M.uint(16777215*Math.random());class z extends T{constructor(e){super(e),t(this,"maxCount",5e4),t(this,"count",5e3),t(this,"collisionCamera"),t(this,"renderTarget"),t(this,"material"),t(this,"positionBuffer"),t(this,"velocityBuffer"),t(this,"ripplePositionBuffer"),t(this,"rippleTimeBuffer"),t(this,"computeParticles"),t(this,"rainParticles"),t(this,"rippleParticles"),t(this,"collisionBox"),t(this,"gui"),this.collisionCamera=this.createCollisionCamera(),this.renderTarget=this.createRenderTarget();const n=new i;n.colorNode=M.positionWorld,this.material=n,this.positionBuffer=this.createBuffer(),this.velocityBuffer=this.createBuffer(),this.ripplePositionBuffer=this.createBuffer(),this.rippleTimeBuffer=this.createBuffer();const a=this.initCompute(),r=this.computeUpdate();this.computeParticles=r().compute(this.maxCount),this.addModel(),this.renderer.computeAsync(a),this.gui=new s,this.addGui()}render(){this.renderer.renderAsync(this.scene,this.camera)}createRender(){return new n(this.options.render)}createCollisionCamera(){const e=new a(-50,50,50,-50,.1,50);return e.position.y=50,e.lookAt(0,0,0),e.layers.disableAll(),e.layers.enable(1),e}createRenderTarget(){const e=new r(1024,1024),t=e.texture;return t.type=o,t.magFilter=l,t.minFilter=l,t.generateMipmaps=!1,e}createBuffer(e="vec3"){const t=this.maxCount;return M.storage(new c(t,3),e,t)}initCompute(){return M.Fn((()=>{const e=this.positionBuffer.element(M.instanceIndex),t=this.velocityBuffer.element(M.instanceIndex),i=this.rippleTimeBuffer.element(M.instanceIndex),s=M.hash(M.instanceIndex),n=M.hash(M.instanceIndex.add(R())),a=M.hash(M.instanceIndex.add(R()));e.x=s.mul(100).add(-50),e.y=n.mul(25),e.z=a.mul(100).add(-50),t.y=s.mul(-.04).add(-.2),i.x=1e3}))().compute(this.maxCount)}computeUpdate(){return M.Fn((()=>{const e=e=>e.add(50).div(100),t=this.positionBuffer.element(M.instanceIndex),i=this.velocityBuffer.element(M.instanceIndex),s=this.ripplePositionBuffer.element(M.instanceIndex),n=this.rippleTimeBuffer.element(M.instanceIndex);t.addAssign(i),n.x=n.x.add(M.deltaTime.mul(4));const a=M.texture(this.renderTarget.texture,e(t.xz)).y.add(.05);M.If(t.y.add(-.9).lessThan(a),(()=>{t.y=25,s.xz=t.xz,s.y=a,n.x=1,t.x=M.hash(M.instanceIndex.add(M.time)).mul(100).add(-50),t.z=M.hash(M.instanceIndex.add(M.time.add(R()))).mul(100).add(-50)}));const r=M.texture(this.renderTarget.texture,e(s.xz)).y.add(.05);M.If(s.y.greaterThan(r),(()=>{n.x=1e3}))}))}addModel(){this.createRainDrop(),this.createRainRipple(),this.createCollisionGround(),this.createCollisionModel()}createRainDrop(){const e=new i;e.colorNode=M.uv().distance(M.vec2(.5,0)).oneMinus().mul(3).exp().mul(.1),e.vertexNode=M.billboarding({position:this.positionBuffer.toAttribute()}),e.opacity=.2,e.side=d,e.forceSinglePass=!0,e.depthWrite=!1,e.depthTest=!0,e.transparent=!0;const t=new h(new u(.1,2),e);t.count=this.count,this.rainParticles=t,this.addObject(t)}createRainRipple(){const e=this.rippleTimeBuffer.element(M.instanceIndex).x,t=M.Fn((()=>{const t=M.uv().add(M.vec2(-.5)).length().mul(7),i=e.sub(t);return i.min(1).sub(i.max(1).sub(1))})),s=new i;s.colorNode=t(),s.positionNode=M.positionGeometry.add(this.ripplePositionBuffer.toAttribute()),s.opacityNode=e.mul(.3).oneMinus().max(0).mul(.5),s.side=d,s.forceSinglePass=!0,s.depthWrite=!1,s.depthTest=!0,s.transparent=!0;const n=new u(2.5,2.5);n.rotateX(-Math.PI/2);const a=new u(1,2);a.rotateY(-Math.PI/2);const r=new u(1,2),o=p([n,a,r]),l=new h(o,s);l.count=this.count,this.rippleParticles=l,this.addObject(l)}createCollisionGround(){const e=new u(1e3,1e3);e.rotateX(-Math.PI/2);const t=new h(e,new m({color:328965}));this.addObject(t)}createCollisionModel(){const e=new h(new f(30,1,15),new x({color:3355443}));e.position.y=12,e.scale.x=3.5,e.layers.enable(1),e.castShadow=!0,this.collisionBox=e,this.addObject(e);const t=new h(new y(5,1,128,100),new x({color:3355443}));t.position.set(0,12,15),t.layers.enable(1),this.addObject(t)}addGui(){var e,t,i;const s=this.gui;s.add(null==(e=this.collisionBox)?void 0:e.position,"z",-50,50),s.add(null==(t=this.collisionBox)?void 0:t.scale,"x",.1,4),s.add(this.rainParticles,"count",200,this.maxCount).name("数量").onChange((e=>{this.rippleParticles.count=e})),s.domElement.className+=" gui-wrap",null==(i=this.container.parentNode)||i.appendChild(s.domElement)}animate(){const e=this.renderer;e&&(this.scene.overrideMaterial=this.material,e.setRenderTarget(this.renderTarget),e.renderAsync(this.scene,this.collisionCamera),e.computeAsync(this.computeParticles),this.scene.overrideMaterial=null,e.setRenderTarget(null),this.render())}}const A={class:"three-page"},j=g({__name:"index",setup(e){const t=B(),i={grid:{},render:{antialias:!0,logarithmicDepthBuffer:!1},axes:{visible:!0},ambientLight:{color:1118481},directionalLight:{position:[3,17,17]},camera:{position:[40,8,0]},controls:{maxDistance:50}};let s;return w((()=>{i.container=t.value,s=new z(i),s.run(),I(s).resize()})),(e,i)=>(v(),C("div",A,[P("div",{class:"h-100",ref_key:"containerRef",ref:t},null,512)]))}});export{j as default};
