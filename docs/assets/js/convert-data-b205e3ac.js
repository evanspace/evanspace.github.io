import{cB as e,cC as n,ba as t,bG as o,b3 as a,c1 as r,cb as i,bm as l,cc as s,cd as c,br as u,c0 as d,cD as v,cE as p,bs as f,cF as g,b4 as m,cG as h,cH as w,cI as y,ck as x,cJ as S,cl as C,bw as A,bq as I,a_ as L,bn as b,bu as z,cK as P,ce as U,i as O,cL as T}from"./vendor-eaf8386d.js";import{d as R,r as W}from"./scene-resize-5f43ff70.js";const M=(u={})=>{let d=R({range:100,interval:.8,size:.2,color:47273,light:881527,factor:1},u);const v=(e,n)=>{const t=e.material,o=t.uniforms.uRange.value,a=t.uniforms.uLength.value;t.uniforms.uRadius.value+=n*(o/4),t.uniforms.uRadius.value>=o+a&&(t.uniforms.uRadius.value=0)};return{createCorrugatedPlate:(u={})=>{d=R(d,u);let{range:v,color:p,light:f,factor:g}=d;v*=g;const m=(()=>{let{range:e,interval:n,size:t,factor:o}=d;e*=o,n*=o,t*=o;const a=[],u=Math.floor(e/n);for(let d=-u;d<=u;d++)for(let e=-u;e<=u;e++){const o=new r(t,t),u=d*n,v=e*n,p=new i,f=new l(u,-t,v),g=new s,m=new c,h=new l(1,1,1);g.setFromEuler(m),p.compose(f,g,h),o.applyMatrix4(p),a.push(o)}return a})(),h=e(m),w=new n({uniforms:{uColor:{value:new t(f)},uTcolor:{value:new t(p)},uRadius:{value:1.25},uLength:{value:v/10},uRange:{value:v}},vertexShader:"\n        varying vec3 vp;\n        void main(){\n          vp = position;\n          gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        varying vec3 vp;\n        uniform vec3 uColor;\n        uniform vec3 uTcolor;\n        uniform float uRadius;\n        uniform float uLength;\n        float getLeng(float x, float y){\n          return  sqrt((x-0.0)*(x-0.0)+(y-0.0)*(y-0.0));\n        }\n        void main(){\n          float uOpacity = 0.8;\n          vec3 vColor = uColor;\n          float length = getLeng(vp.x,vp.z);\n          if ( length <= uRadius && length > uRadius - uLength ) {\n            float op = sin( (uRadius - length) / uLength ) ;\n            uOpacity = op;\n            if ( vp.y < 0.0 ) {\n              vColor = uColor * op;\n            } else {\n              vColor = uTcolor;\n            };\n            vColor = uTcolor;\n          }\n          gl_FragColor = vec4(vColor,uOpacity);\n        }\n      ",transparent:!0,depthWrite:!1,side:o}),y=new a(h,w);return y.name="波纹板",y},update:v,corrugatedPlateUpdate:v}},E=(e={})=>{let o=R({size:.1,color:16085360,range:500,factor:1,speed:6},e);const a=e=>{const n=e.material,t=n.uniforms.uLength.value;n.uniforms.uIndex.value+=o.speed,n.uniforms.uIndex.value>=t&&(n.uniforms.uIndex.value=0)};return{createOutline:(e,a={})=>{o=R(o,a);const{size:r,factor:i,range:l,color:s}=o,c=new Float32Array(e),p=new u;p.setAttribute("position",new d(c,3));const f=new Float32Array(Math.floor(c.length/3)).map(((e,n)=>n));p.setAttribute("aIndex",new d(f,1));const g=new n({vertexShader:"\n        attribute float aOpacity;\n        uniform float uSize;\n\n        attribute float aIndex;\n        varying vec3 vp;\n        varying float vertexIndex;\n\n        void main(){\n          gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);\n          gl_PointSize = uSize;\n\n          vp = position;\n          vertexIndex = aIndex;\n        }\n      ",fragmentShader:"\n        varying float vertexIndex;\n        uniform vec3 uColor;\n        uniform float uIndex;\n        uniform float uRange;\n\n        float invert(float n){\n          return 1.-n;\n        }\n\n        void main(){\n          float uOpacity = 1.0;\n          if(vertexIndex <= uIndex || vertexIndex >= (uRange + uIndex)){\n              discard;\n          }\n          uOpacity = (vertexIndex - uIndex)/uRange;\n          if ( uOpacity < 0.2) {\n            discard;\n          }\n          vec2 uv=vec2(gl_PointCoord.x,invert(gl_PointCoord.y));\n          vec2 cUv=2.*uv-1.;\n          vec4 color=vec4(1./length(cUv));\n          color*=uOpacity;\n          color.rgb*=uColor;\n          gl_FragColor=color;\n        }\n      ",transparent:!0,depthTest:!1,uniforms:{uSize:{value:r*i},uIndex:{value:0},uLength:{value:f.length},uRange:{value:l},uColor:{value:new t(s)}}}),m=new v(p,g);return m.name="轮廓",m.scale.setScalar(i),m},update:a,outlineUpdate:a}},X=()=>({getBoundingBox:e=>{var n=new p;n.expandByObject(e);var t=new l;n.getSize(t);var o=new l;return n.getCenter(o),{box3:n,center:o,size:t}}}),D=()=>{const e=(e,n,t="LineLoop")=>{let o;if("Line2"===t){const t=new h;t.setPositions(e),o=new w(t,n),o.name="countryLine2",o.computeLineDistances()}else{const a=new u;a.setFromPoints(e),o=new y[t](a,n),o.name="countryLine"}return o};return{createCountryFlatLine:(n,t={},o="LineLoop")=>{let a={color:65535,linewidth:1,depthTest:!1};a=R(a,t);let r=new f(a);"Line2"===o&&(r=new g(a));let i=n.features,s=new m;for(let c=0;c<i.length;c++){const n=i[c].geometry.coordinates;for(let t=0;t<n.length;t++){const a=n[t],i=[];"Line2"===o?a.forEach((e=>{e.forEach((e=>{i.push(e[0],0,-e[1])}))})):a.forEach((e=>{e.forEach((e=>{i.push(new l(e[0],e[1],0))}))}));let c=e(i,r,o);s.add(c)}}return s},getPoints:(e,n=0,t)=>{let o=e.features;const a=[];for(let r=0;r<o.length;r++){const e=o[r].geometry.coordinates;for(let o=0;o<e.length;o++)e[o].forEach((e=>{e.forEach((e=>{t?a.push(new l(e[0],n,-e[1])):a.push(e[0],n,-e[1])}))}))}return a}}},B=()=>({initCSS3DRender:(e,n)=>{const{width:t,height:o}=e,a=new x;return a.setSize(t,o),a.domElement.style.position="absolute",a.domElement.style.left="0px",a.domElement.style.top="0px",a.domElement.style.pointerEvents="none",n.appendChild(a.domElement),a},createCSS3DDom:e=>{const{name:n,className:t="",onClick:o,position:a,sprite:r}=e,i=document.createElement("div");i.innerHTML=n,i.className=t;const l=r?new S(i):new C(i);return i.style.pointerEvents=o?"auto":"none",i.style.position="absolute","function"==typeof o&&i.addEventListener("click",o),a&&l.position.set(...a),l}}),F=(e={})=>{let n=R({pointTextureUrl:new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+IEmuOgAABCtJREFUWIXVmU1oXFUUx3/zSptF4qYliNAUJB8tUnRhXSiSWhcmEekiXVi1C20Ximm7li5EsFDUrYsuBVeNCCroIgXF2iKtCRioIp1shIC1I0g7TUIS7d/FPTfz+vLu+5i8GewfLjP33vPxf3fu3HfuOTVJbAG9wLPAQeAxYAR4GOiz+bvAn8AN4FfgEvADsNS2R0llW03SuKQLkpZVHsumO262SvmvlVzhSeBd4Anr3wNmgW+BOVvJxdgK9gK7gWHgAHAIeAqIbH4eeA/4ouoVHpQ0E1ulRUlnJO1p4xfaY7qLMXsz5iNXv4iDlyXdNsMNSScl9bRBNNl6zFbDbN+WdHQrhGuSzsZW4TNJuyogmmy7zLbHWWXs7SyyH5uBfySd6gDRZDspad18ng+RDimfM8VlSYe7QNa3lyQtme9zRQkfja1sEbI1SaOSPpB0WdJNSavWbtrYhyZT5Bg7bL4l6ZU8woNq/cFO5xiOJB2XVFdx1E0nyrF92uTvKHF6JAX90TWdY/BRSddKEE3imtnI8jFtsjMhwpMm8Jek/gxDz6l1FG0FDbltEvKzU9Itk51MEq5J+tkmpzKMvCC3N6vCqqSxDH9vmdy8cdwgPGYTv0vaHlDeK7enqkbTbKf53G6cJBd7bLzT37DP88B6yht8G/Ap8FDhd35x9JntbSlz68YJ4HUAJPVKWpH0r6SBwJMe78DKJnEi4HvAuK1I6o1vh6sBhZrKHV3toq7wOX3VZMYiXPANLkRMwygwVNkGCGPIfKXBczsYAfutMxcQfrFKVjkI+fLc9ke44Brgt4DwM5VSysbTgXHPbTgC+q3zR0B4ODDeCYwExj23/pqkVWAH0AOspQj7+W5gzXgkscN4rEUpk/9rREDTvodeCn93iUuWL8+tGQEN6zwSEK5XSikbNwLjnlsjokVob0D4x0opZSPky3OrR8B16zwZEP66UkrZ+CYwfsA+r0e49BHA8wHhS8BClawCWMClsdJwaIOLigU/J7oQSxQKfiJcWulL3IlxLPCEn+BSUp3CnPlIwzEct6+AJf8U4/aUWQH8Prlgu2o0zXZeAD+hxBVp3ibeDihjSlVfkSYy/L1pcpuuSGUuoROqZqWbOWTjl9AjfjwpVPSav0/S7BbIziq8DXy7YLIX4+NJoUG1Lpp5+TSfSFkoQXRBxRIpp0z+jqShLMKofKoqkssvfCTpijanqq7Y3GgBoqhkqsq3ByoZiB7AdKsnHU9oT6szCe2dauXRpDYT2vH2qu4vGUypupLBlO4vGbyWp1fU+JDc8eKxKOkdtVeUGTDdeFHmohKnQaiVLXsdwZW9Hrf+PeAn4DtcrOHLXndtvg9X9hohXPZ6H/i8MIM2VsgXFqflIqiyWDHdrhQWk+jDlW5HcQmZYTaXbm/hVv4X4HvgMq1foDT+A+dj9DaZa2PgAAAAAElFTkSuQmCC",self.location).href,circleTextureUrl:new URL("/imgs/circle-f2c3f6ed.png",self.location).href,lightTextureUrl:new URL("/imgs/light-aa132c89.png",self.location).href,factor:1,color:65535},e);const t=new A;return{createMarkLight:(e=[0,0,0],i=10,l={})=>{n=R(n,l);const s=new m,c=new r(i/6.219,i);c.rotateX(-Math.PI/2),c.translate(0,0,i/2);const u=new I({map:t.load(n.lightTextureUrl),color:n.color,transparent:!0,depthWrite:!1,side:o});let d=new a(c,u);d.rotateX(Math.PI),d.position.z=i,d.renderOrder=3,d.name="光柱 01";let v=d.clone();v.name="光柱 02",v.rotateZ(Math.PI/2);const p=(()=>{const e=new r(3,3),i=new I({map:t.load(n.pointTextureUrl),color:n.color,side:o,transparent:!0,depthWrite:!1});let l=new a(e,i);l.renderOrder=1,l.name="底部光点";const s=.3*n.factor;return l.scale.setScalar(s),l})(),f=(()=>{const e=new r(3,3),i=new I({map:t.load(n.circleTextureUrl),color:n.color,side:o,opacity:0,transparent:!0,depthWrite:!1});let l=new a(e,i);l.renderOrder=2,l.name="createLightHalo";const s=.5*n.factor;l.scale.setScalar(s);const c=W(0,2e3);return l.tween1=new L({scale:s,opacity:0}).to({scale:1.5*s,opacity:1},1e3).delay(c).onUpdate((e=>{let{scale:n,opacity:t}=e;l.scale.setScalar(n),l.material.opacity=t})),l.tween2=new L({scale:1.5*s,opacity:1}).to({scale:2*s,opacity:0},1e3).onUpdate((e=>{let{scale:n,opacity:t}=e;l.scale.setScalar(n),l.material.opacity=t})),l.tween1.chain(l.tween2),l.tween2.chain(l.tween1),l.tween1.start(),l})();return s.add(d,v,p,f),s.position.set(...e),s.rotateX(.5*Math.PI),s.name="光柱标记",s}}},k=(e={})=>{let i,s,c=R({depth:0,height:4,divisions:1e3,color:16777215,flyColor:16761095,pointColor:16715760,pointWidth:2.5,flyPointWidth:2.4,tubularSegments:256,radius:.5,radialSegments:8,closed:!1,length:100,factor:1,speed:4},e);const p=e=>{const[n,t]=e;let{pointWidth:o,depth:i,factor:l}=c;const u=o*l;i*=l;const d=new r(u,u,1,1),v=new a(d,s);return v.position.set(n,i,-t),v.rotateX(.5*-Math.PI),v},f=(e={})=>{c=R(c,e),i=new n({depthTest:!1,uniforms:{uColor:{value:new t(c.flyColor)},uIndex:{value:0},uTotal:{value:c.divisions},uWidth:{value:c.flyPointWidth},uLength:{value:c.length}},vertexShader:"\n        attribute float aIndex;\n        uniform float uIndex;\n        uniform float uWidth;\n        uniform vec3 uColor;\n        varying float vSize;\n        uniform float uLength;\n  \n        void main(){\n            vec4 viewPosition = viewMatrix * modelMatrix * vec4(position,1);\n            gl_Position = projectionMatrix * viewPosition;\n  \n            if(aIndex >= uIndex - uLength && aIndex < uIndex){\n              vSize = uWidth * ((aIndex - uIndex + uLength) / uLength);\n            }\n            gl_PointSize = vSize;\n        }\n      ",side:o,fragmentShader:"\n        varying float vSize;\n        uniform vec3 uColor;\n        void main(){\n            if(vSize<=0.0){\n              gl_FragColor = vec4(1,0,0,0);\n            }else{\n              gl_FragColor = vec4(uColor,1);\n            }\n        }\n      ",transparent:!0,vertexColors:!1}),s=new n({uniforms:{uColor:{value:new t(c.pointColor)},uOpacity:{value:1},uSpeed:{value:.1},uSge:{value:4},uRadius:{value:c.pointWidth*c.factor/2},time:{value:0}},transparent:!0,depthTest:!1,vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          // 最终顶点位置信息=投影矩阵*模型视图矩阵*每个顶点坐标\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n      ",fragmentShader:"\n        varying vec2 vUv;\n        uniform vec3 uColor;\n        uniform float uOpacity;\n        uniform float uSpeed;\n        uniform float uSge;\n        uniform float time;\n        float PI = 3.14159265;\n        float drawCircle(float index, float range) {\n          float opacity = 1.0;\n          if (index >= 1.0 - range) {\n            opacity = 1.0 - (index - (1.0 - range)) / range;\n          } else if(index <= range) {\n            opacity = index / range;\n          }\n          return opacity;\n        }\n        float distanceTo(vec2 src, vec2 dst) {\n          float dx = src.x - dst.x;\n          float dy = src.y - dst.y;\n          float dv = dx * dx + dy * dy;\n          return sqrt(dv);\n        }\n        void main() {\n          float iTime = -time * uSpeed;\n          float opacity = 0.0;\n          float len = distanceTo(vec2(0.5, 0.5), vec2(vUv.x, vUv.y));\n  \n          float size = 1.0 / uSge;\n          vec2 range = vec2(0.65, 0.75);\n          float index = mod(iTime + len, size);\n          // 中心圆\n          vec2 cRadius = vec2(0.06, 0.12);\n  \n          if (index < size && len <= 0.5) {\n            float i = sin(index / size * PI);\n  \n            // 处理边缘锯齿\n            if (i >= range.x && i <= range.y){\n              // 归一\n              float t = (i - range.x) / (range.y - range.x);\n              // 边缘锯齿范围\n              float r = 0.3;\n              opacity = drawCircle(t, r);\n            }\n            // 渐变\n            opacity *=  1.0 - len / 0.5;\n          };\n          gl_FragColor = vec4(uColor, uOpacity * opacity);\n        }\n      ",side:o})},g=()=>{const e=i,n=e.uniforms.uTotal.value;e.uniforms.uIndex.value+=c.speed,e.uniforms.uIndex.value>=n&&(e.uniforms.uIndex.value=0);const t=.001*performance.now();s.uniforms.time.value=t};return f(),{createFlywireTexture:f,createFlywire:e=>{const o=new m,r=p(e[0]),s=p(e[1]);o.add(r,s);const f=(e=>{const[n,t]=e[0],[o,a]=e[1];let{depth:r,height:i,factor:s,divisions:u}=c;i=(r+i)*s,r*=s;const d=new l(n,r,-t),v=new l(n+(o-n)/4,i,-(t+(a-t)/4)),p=new l(n+3*(o-n)/4,i,-(t+3*(a-t)/4)),f=new l(o,r,-a);return new P(d,v,p,f).getPoints(u)})(e),g=new b(f,!1,"centripetal",.5),h=new z(g,c.tubularSegments,c.radius,c.radialSegments,c.closed),w=new n({transparent:!0,opacity:1,depthTest:!1,vertexColors:!1,uniforms:{uColor:{value:new t(c.color)},uOpacity:{value:.6}},vertexShader:"\n        varying vec3 vColor;\n        uniform vec3 uColor;\n        void main() {\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor;\n        uniform float uOpacity;\n        void main() {\n          gl_FragColor = vec4(uColor, uOpacity);\n        }\n      "}),y=new a(h,w);y.renderOrder=10;const x=(e=>{const n=new Float32Array(e.map(((e,n)=>n))),t=(new u).setFromPoints(e);return t.setAttribute("aIndex",new d(n,1)),new v(t,i)})(f);return o.add(y,x),o},update:g,flywireUpdate:g}},{createCSS3DDom:H}=B(),j=(e={})=>{let o=R({height:10,size:2,factor:1,color1:1048575,color2:16777215},e);return{createBar:(e={},r={})=>{o=R(o,r);let{size:i,height:l,factor:s,color1:c,color2:u}=o;i*=s,l*=s,l*=e.heightRatio??s;const[d,v,p]=e.position||[0,0,0],f=new m,g=new U(i,i,l),h=new n({depthTest:!1,transparent:!0,vertexColors:!1,uniforms:{uColor1:{value:new t(c)},uColor2:{value:new t(u)},uOpacity:{value:.6}},vertexShader:"\n        varying vec3 vColor;\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        void main() {\n          float percent = (position.z + 0.0) / 100.0; // 计算当前像素点在立方体高度上的百分比\n          vColor = mix(uColor1.rgb, uColor2.rgb, percent);\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        varying vec3 vColor;\n        uniform float uOpacity;\n        void main() {\n          gl_FragColor = vec4(vColor, uOpacity);\n        }\n      "}),w=new a(g,h);if(f.add(w),f.name="柱状图",f.position.set(d,v,p+l/2),f.renderOrder=99,e.label){const{name:n="",className:t="",onClick:o}=e.label,a=H({name:n,className:t,position:[0,0,l/2],onClick:o});a.rotateX(.5*Math.PI),f.add(a)}return f}}},N=()=>{const e=O(0);return{load:n=>{const t=new T;return new Promise(((o,a)=>{t.load(n,(e=>{let n={};try{n=JSON.parse(e)}catch(t){}o(n)}),(n=>{let{loaded:t,total:o}=n;e.value=Number((t/o*100).toFixed(0))}),a)}))},progress:e}},J=()=>({transformGeoJSON:e=>{let n=e.features;for(let t=0;t<n.length;t++){const e=n[t];"Polygon"===e.geometry.type&&(e.geometry.coordinates=[e.geometry.coordinates])}return e}});export{E as a,F as b,k as c,j as d,X as e,D as f,B as g,N as h,J as i,M as u};
