{"version":3,"file":"index-64676fc3.js","sources":["../../../code/src/mixins/common.ts","../../../code/src/pages/webgl/effect/water/index.vue"],"sourcesContent":["import * as THREE from 'three'\nimport * as TWEEN from 'three/examples/jsm/libs/tween.module.js'\n// import TWEEN from '@tweenjs/tween.js'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\n// import { LoaderUtils } from 'three/src/loaders/LoaderUtils'\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader'\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader'\n// import { TGALoader } from 'three/examples/jsm/loaders/TGALoader'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\n\nimport { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter'\n\n// 创建渲染器\nexport const createRender = (dom: HTMLElement) => {\n  const width = dom.clientWidth,\n    height = dom.clientHeight\n  // 创建渲染对象\n  const renderer = new THREE.WebGLRenderer({\n    // 是否开启反锯齿，设置为true开启反锯齿\n    antialias: true\n    // 透明度\n    // alpha: true,\n  })\n  // renderer.setClearAlpha( 0 )\n\n  // 设置渲染尺寸\n  renderer.setSize(width, height)\n  // 像素比例\n  renderer.setPixelRatio(window.devicePixelRatio)\n  // 画布插入容器\n  dom.appendChild(renderer.domElement)\n  return renderer\n}\n\n// 创建透视相机\nexport const createPerspectiveCamera = (dom: HTMLElement, near = 0.1, far = 10000) => {\n  // 相机设定\n  const width = dom.clientWidth,\n    height = dom.clientHeight\n  // 透视投影相机对象 参数（现场角度，窗口长宽比，开始渲染位置，结束渲染位置）\n  const camera = new THREE.PerspectiveCamera(36, width / height, near, far)\n  camera.position.set(-350, 510, 700) // 相机位置\n  return camera\n}\n\n// 创建方向光\nexport const createDirectionalLight = (\n  color = 0xffffff,\n  intensity = 1,\n  s = 800,\n  size = 2048,\n  near = 1,\n  far = 2000\n) => {\n  // 平行光\n  const dirLight = new THREE.DirectionalLight(color, intensity)\n  dirLight.position.set(500, 800, 500)\n  dirLight.castShadow = true\n  dirLight.shadow.camera.near = near\n  dirLight.shadow.camera.far = far\n  dirLight.shadow.camera.right = s\n  dirLight.shadow.camera.left = -s\n  dirLight.shadow.camera.top = s\n  dirLight.shadow.camera.bottom = -s\n\n  dirLight.shadow.mapSize.set(size, size)\n  return dirLight\n}\n\n// 创建控制器\nexport const createControl = (camera, renderer) => {\n  // 创建控件\n  const controls = new OrbitControls(camera, renderer.domElement)\n\n  // 最大最小相机移动距离(景深相机)\n  controls.minDistance = 0.1\n  // controls.maxDistance = 3000\n\n  // 最大仰视角\n  controls.maxPolarAngle = Math.PI * 0.495 * 1.1\n\n  // 聚焦坐标\n  controls.target.set(0, 20, 0)\n  return controls\n}\n\n// 创建网格\nexport const createLayoutGrid = () => {\n  // 网格宽度、等分数、中心线颜色、网格颜色\n  let grid = new THREE.GridHelper(800, 80, 0xa1a1a1, 0xa1a1a1)\n  // grid.visible = false\n  grid.material.opacity = 0.3\n  grid.material.transparent = true\n  return grid\n}\n\n// 加载背景图\nexport const loadBackground = (scene, baseUrl) => {\n  let loader = new THREE.CubeTextureLoader()\n  let env = loader.load([\n    `${baseUrl}/posX.jpeg`,\n    `${baseUrl}/negX.jpeg`,\n    `${baseUrl}/posY.jpeg`,\n    `${baseUrl}/negY.jpeg`,\n    `${baseUrl}/posZ.jpeg`,\n    `${baseUrl}/negZ.jpeg`\n  ])\n  // 设置背景\n  scene.background = env\n}\n\ninterface ToVx {\n  x: number\n  y: number\n  z: number\n}\n// 相机入场动画\nexport const cameraInSceneAnimate = (camera: any, to: ToVx, at: ToVx) => {\n  camera.lookAt(at)\n  return new Promise(resolve => {\n    new TWEEN.Tween(camera.position)\n      .to(to, 1000)\n      .easing(TWEEN.Easing.Quadratic.In)\n      .start()\n      .onUpdate(() => {\n        // 设置相机对焦位置\n        camera.lookAt(at)\n      })\n      .onComplete(() => {\n        resolve(camera)\n      })\n  })\n}\n\n// 材质优化 材质、是否反光、是否粗糙\nexport const materialOptimize = (mat: any, glisten?: boolean, side?: boolean) => {\n  if (mat instanceof Array) {\n    let material = mat.map(mt => {\n      return materialOptimize(mt, glisten, side)\n    })\n    mat = material\n  } else {\n    if (!glisten) {\n      // 材质像金属的程度. 非金属材料，如木材或石材，使用0.0，金属使用1.0，中间没有（通常）.\n      // 默认 0.5. 0.0到1.0之间的值可用于生锈的金属外观\n      mat.metalness = 0.5\n      // 材料的粗糙程度. 0.0表示平滑的镜面反射，1.0表示完全漫反射. 默认 0.5\n      mat.roughness = 0.9\n    } else {\n      // mat.side = THREE.DoubleSide\n      mat.metalness = 0.5\n      mat.roughness = 0\n    }\n    // child.material.emissiveMap = child.material.map\n    mat = new THREE.MeshStandardMaterial({\n      color: mat.color, // 颜色\n      map: mat.map, // 贴图\n      emissive: mat.emissive || mat.color, // 发光\n      emissiveIntensity: mat.emissiveIntensity,\n      emissiveMap: mat.emissiveMap,\n      bumpMap: mat.bumpMap, // 凹凸\n      normalMap: mat.normalMap, // 法线\n      displacementMap: mat.displacementMap, // 移动\n      opacity: mat.opacity, // 透明度\n      transparent: mat.transparent, // 透明\n      metalness: mat.metalness, // 金属度\n      roughness: mat.roughness, // 粗糙度\n      side: side ? THREE.DoubleSide : THREE.FrontSide // 材质渲染面\n    })\n  }\n  return mat\n}\n\ninterface ReplaceOpts {\n  // 转换材质\n  transformMaterial: boolean\n  // 材质反光\n  glisten: boolean\n  // 地面反光\n  groundReflection: boolean\n  // 双面\n  side: boolean\n  // 透明外壳\n  opacitySkin: boolean\n  // 透明度\n  opacity: number\n}\n\nexport const changeTransparent = (mode, opacity = 0.5) => {\n  // 改变透明度\n  const change = mesh => {\n    mesh.material.transparent = true\n    mesh.material.opacity = opacity\n  }\n  if (mode.isMesh) {\n    change(mode)\n  } else {\n    mode.traverse(mode => {\n      if (mode.isMesh) {\n        change(mode)\n      }\n    })\n  }\n}\n\n// 材质替换  动画部分材质颜色\nexport const materialReplace = (opts: ReplaceOpts, child, color = 0x127e12) => {\n  const meshNames = [\n    '螺杆A',\n    '螺杆B',\n    '螺杆A001',\n    '螺杆B001',\n    '螺杆A002',\n    '螺杆B002',\n    '叶轮A',\n    '叶轮B',\n    '叶轮C',\n    '阀门'\n  ]\n  const { type, name } = child\n  // 灯光\n  if (type.indexOf('Light') > -1) {\n  }\n  if (opts.opacitySkin && /[透明外壳]/.test(name)) {\n    changeTransparent(child, opts.opacity)\n  }\n  if (!opts.transformMaterial) return\n\n  const base = ['楼板', '地面', '底座', '基础', '基础底座', '冷却塔基础']\n  if (base.find(it => name.indexOf(it) > -1)) {\n    // 接收阴影\n    child.receiveShadow = true\n    const glisten = name == '地面' ? opts.groundReflection : false\n    child.material = materialOptimize(child.material, glisten, opts.side)\n  } else if (meshNames.find(it => name.indexOf(it) > -1)) {\n    // 动画材质\n    let material = new THREE.MeshStandardMaterial({\n      color: color,\n      // 材质像金属的程度. 非金属材料，如木材或石材，使用0.0，金属使用1.0，中间没有（通常）.\n      // 默认 0.5. 0.0到1.0之间的值可用于生锈的金属外观\n      metalness: 0.6,\n      // 材料的粗糙程度. 0.0表示平滑的镜面反射，1.0表示完全漫反射. 默认 0.5\n      roughness: 0.6\n    })\n    child.material = material\n  } else if (child.isMesh) {\n    child.castShadow = true\n    // let nameArr = [ '墙体', '外墙' ]\n    // if ( nameArr.includes( child.name ) ) return\n\n    child.material = materialOptimize(child.material, opts.glisten, opts.side)\n  }\n}\n\n// 导出坐标\nexport const exportPoints = (list: Array<any>) => {\n  let text = <Array<string>>[]\n  let points = list.map((el: any) => {\n    let p = <any>el.position\n    // text.push( `${ el.name }： ${ p.x.toFixed(1) * 1 }, ${ p.y.toFixed(1) * 1 }, ${ p.z.toFixed(1) * 1 }` )\n    text.push(\n      `${el.name}：{ \"x\": ${p.x.toFixed(1) * 1}, \"y\": ${p.y.toFixed(1) * 1}, \"z\": ${\n        p.z.toFixed(1) * 1\n      } },`\n    )\n\n    return `new THREE.Vector3( ${p.x}, ${p.y}, ${p.z} )`\n  })\n  console.log(points)\n\n  const ptx = '\\n' + text.join('\\n')\n  console.log(ptx)\n}\n\n// 上传文件\nconst env = import.meta.env\nconst beforePath = env.VITE_BEFORE_STATIC_PATH\nexport const uploadFile = (files: any, onSuccess: Function, onProgress?: Function) => {\n  const file = files[0]\n  console.log(file)\n  const filename = file.name\n  const type = filename.split('.').pop().toLowerCase()\n\n  const reader = new FileReader()\n  reader.addEventListener('progress', event => {\n    const size = '(' + Math.floor(event.total / 1000) + ' KB)'\n    const progress = Math.floor((event.loaded / event.total) * 100) + '%'\n    console.log('Loading', filename, size, progress)\n    if (onProgress) onProgress({ progress })\n  })\n\n  reader.addEventListener('load', async (event: any) => {\n    const contents = event.target.result\n    if (['glb', 'gltf'].includes(type)) {\n      const loader = new GLTFLoader()\n      const dracoLoader = new DRACOLoader()\n\n      dracoLoader.setDecoderPath(`${beforePath}/three/draco/gltf/`)\n      loader.setDRACOLoader(dracoLoader)\n      loader.parse(contents, '', result => {\n        console.log(result)\n        const object = result.scene.children[result.scene.children.length - 1]\n        object.name = filename\n        object.animations.push(...result.animations)\n        console.log(type, ' 模型', object)\n        onSuccess(object)\n      })\n    } else if (type == 'fbx') {\n      const loader = new FBXLoader()\n      const object = loader.parse(contents, '')\n      console.log(type, ' 模型', object)\n      onSuccess(object)\n    }\n  })\n  reader.readAsArrayBuffer(file)\n}\n\n// 建筑居中\nexport const centerBuilding = (building: any, hex = 0xff0000) => {\n  var boxHelper = new THREE.BoxHelper(building, hex) // 创建 BoxHelper\n  boxHelper.update() //更新\n  const box = new THREE.Box3().setFromObject(building) // 获取模型的包围盒\n  const center = box.getCenter(new THREE.Vector3())\n  return {\n    helper: boxHelper,\n    center\n  }\n}\n\nconst saveFile = (blob, filename) => {\n  const link = document.createElement('a')\n  link.style.display = 'none'\n  document.body.appendChild(link) // Firefox workaround, see #6594\n\n  link.href = URL.createObjectURL(blob)\n  link.download = filename\n  link.click()\n  link.remove()\n}\n\nconst saveString = (text, filename) => {\n  saveFile(new Blob([text], { type: 'text/plain' }), filename)\n}\n\nconst saveArrayBuffer = (buffer, filename) => {\n  saveFile(new Blob([buffer], { type: 'application/octet-stream' }), filename)\n}\n\n// 导出 glb、gltf 文件\nexport const exportGlb = (model, animations, name, isGlb: boolean = true) => {\n  if (!model) return\n  const gltfExporter = new GLTFExporter()\n  const options = {\n    trs: false,\n    onlyVisible: true,\n    truncateDrawRange: true,\n    binary: isGlb,\n    // maxTextureSize: 1024 || 4096 || Infinity, // To prevent NaN value,\n    animations: animations // 动画\n  }\n  gltfExporter.parse(\n    model,\n    result => {\n      if (result instanceof ArrayBuffer) {\n        console.log(result)\n        saveArrayBuffer(result, name + '.glb')\n      } else {\n        const output = JSON.stringify(result, null, 2)\n        console.log({ output })\n        saveString(output, name + '.gltf')\n      }\n    },\n    error => {\n      console.log('An error happened during parsing', error)\n    },\n    options\n  )\n}\n","<template>\n  <div class=\"page h-100\">\n    <div ref=\"containerRef\" class=\"container h-100\" style=\"position: relative\"></div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport * as THREE from 'three'\nimport * as UTILS from '@/mixins/common'\n\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js'\n\nimport { Water } from 'three/examples/jsm/objects/Water'\nimport { Sky } from 'three/examples/jsm/objects/Sky'\n\nimport { useAssetsStore } from '@/stores'\nconst assetsStore = useAssetsStore()\n\nconst isDev = import.meta.env.VITE_MODE == 'dev'\n\nconst containerRef = ref<HTMLElement>()\n// 场景\nconst scene = new THREE.Scene()\nconst backgroundColor = '#fff'\n// 设置背景色\nscene.background = new THREE.Color(backgroundColor)\n// 相机\nlet camera: any\n// 渲染器\nlet renderer: any\n// 控件\nlet controls: any\n// 网格\nlet grid: any\n\n// 创建光源\nlet ambientLight: any, dirLight: any\nconst createLight = () => {\n  const intensity = 1.5\n  // 环境光\n  ambientLight = new THREE.AmbientLight(0xffffff, intensity)\n  scene.add(ambientLight)\n\n  // 平行光\n  dirLight = UTILS.createDirectionalLight(0xffffff, intensity)\n  // scene.add( dirLight )\n\n  if (isDev) {\n    const dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 1)\n    scene.add(dirLightHelper)\n  }\n}\n\n// 窗口事件\nconst windowResize = () => {\n  const container = <HTMLElement>containerRef.value\n  if (!camera) return\n  const width = container.clientWidth,\n    height = container.clientHeight\n  const k = width / height\n  camera.aspect = k\n  camera.updateProjectionMatrix()\n  renderer.setSize(width, height)\n}\n\nlet __request_animation_frame_id__\nconst animate = () => {\n  __request_animation_frame_id__ = requestAnimationFrame(animate)\n\n  // 模型动画\n  modelAnimate()\n\n  renderer.render(scene, camera)\n}\n\n// 模型动画\nconst modelAnimate = () => {\n  // performance-获取当前页面信息api\n  // 返回从性能测量开始到现在的毫秒数\n  let time = performance.now() * 0.001\n\n  // 上下浮动效果\n  geometryMesh.position.y = Math.sin(time) * 20 + 5\n  // 旋转效果\n  geometryMesh.rotation.x = time * 0.5\n  geometryMesh.rotation.z = time * 0.51\n\n  // 水面波动\n  water.material.uniforms['time'].value += 1 / 60\n}\n\n// 系数控制参数\nconst effectController = reactive<any>({\n  turbidity: 10, // 浑浊\n  rayleigh: 2, // 视觉效果就是傍晚晚霞的红光的深度\n  mieCoefficient: 0.005, // 粒子的米氏散射系数\n  mieDirectionalG: 0.2, // 方向\n  elevation: 2, // 太阳高度\n  azimuth: 180, // 太阳角度\n  exposure: null // 光晕强度\n})\nlet pmremGenerator: any\nconst initModel = () => {\n  createWater()\n  createSky()\n\n  // 色调映射\n  renderer.toneMapping = THREE.ACESFilmicToneMapping\n  renderer.toneMappingExposure = 1\n\n  effectController.exposure = renderer.toneMappingExposure\n  // 环境映射\n  pmremGenerator = new THREE.PMREMGenerator(renderer)\n  sun = new THREE.Vector3()\n  updateSkyAndSun()\n\n  addGeometry()\n}\n\n// 创建水面\nlet water: any\nconst createWater = () => {\n  // 创建水面\n  const waterGeometry = new THREE.PlaneGeometry(10000, 10000)\n  water = new Water(waterGeometry, {\n    textureWidth: 512,\n    textureHeight: 512,\n    waterNormals: new THREE.TextureLoader().load(\n      `${assetsStore.oss}/textures/waternormals.jpg`,\n      texture => {\n        texture.wrapS = texture.wrapT = THREE.RepeatWrapping\n      }\n    ),\n    sunDirection: new THREE.Vector3(),\n    sunColor: 0xffffff,\n    waterColor: 0x001e0f,\n    distortionScale: 3.7,\n    fog: scene.fog !== undefined\n  })\n  water.rotation.x = -Math.PI / 2\n  scene.add(water)\n}\n\n// 创建天空\nlet sky: any\nconst createSky = () => {\n  // 创建天空\n  sky = new Sky()\n  sky.scale.setScalar(10000)\n  scene.add(sky)\n}\n\n// 更新天空和太阳\nlet sun: any\nconst updateSkyAndSun = () => {\n  const skyUniforms = sky.material.uniforms\n\n  skyUniforms['turbidity'].value = effectController.turbidity\n  skyUniforms['rayleigh'].value = effectController.rayleigh\n  skyUniforms['mieCoefficient'].value = effectController.mieCoefficient\n  skyUniforms['mieDirectionalG'].value = effectController.mieDirectionalG\n\n  const phi = THREE.MathUtils.degToRad(90 - effectController.elevation)\n  const theta = THREE.MathUtils.degToRad(effectController.azimuth)\n\n  // 设置球坐标系\n  sun.setFromSphericalCoords(1, phi, theta)\n  // 太阳方位\n  sky.material.uniforms['sunPosition'].value.copy(sun)\n\n  // 太阳方向\n  water.material.uniforms['sunDirection'].value.copy(sun).normalize()\n\n  // 场景环境\n  scene.environment = pmremGenerator.fromScene(sky).texture\n\n  // 场景光晕强度\n  renderer.toneMappingExposure = effectController.exposure\n}\n\n// 添加几何体\nlet geometryMesh: any\nconst addGeometry = () => {\n  let geometry = new THREE.BoxGeometry(30, 30, 30)\n  let material: any = new THREE.MeshStandardMaterial({ roughness: 0, color: 0x000555 }) //  roughness-粗糙度\n  geometryMesh = new THREE.Mesh(geometry, material)\n  scene.add(geometryMesh)\n}\n\n// 添加 GUI\nconst addGui = (dom: HTMLElement) => {\n  const gui = <any>new GUI()\n  const folderSky = gui.addFolder('Sky')\n  folderSky.add(effectController, 'turbidity', 0, 100, 0.1).name('浑浊').onChange(updateSkyAndSun)\n  folderSky.add(effectController, 'rayleigh', 0, 4, 0.001).name('锐利').onChange(updateSkyAndSun)\n  folderSky\n    .add(effectController, 'mieCoefficient', 0, 0.1, 0.001)\n    .name('散射系数')\n    .onChange(updateSkyAndSun)\n  folderSky\n    .add(effectController, 'mieDirectionalG', 0, 1, 0.001)\n    .name('方向')\n    .onChange(updateSkyAndSun)\n  folderSky.add(effectController, 'elevation', 0, 90, 0.1).name('高度').onChange(updateSkyAndSun)\n  folderSky.add(effectController, 'azimuth', -180, 180, 0.1).name('方位').onChange(updateSkyAndSun)\n  folderSky\n    .add(effectController, 'exposure', 0, 1, 0.0001)\n    .name('光晕强度')\n    .onChange(updateSkyAndSun)\n\n  const folderWater = gui.addFolder('Water')\n  const waterUniforms = water.material.uniforms\n  folderWater.add(waterUniforms.distortionScale, 'value', 0, 100, 0.1).name('变形尺度')\n  folderWater.add(waterUniforms.size, 'value', 0.1, 10, 0.1).name('大小')\n\n  gui.domElement.style = 'position: absolute; top: 10px; right: 10px'\n  dom.appendChild(gui.domElement)\n}\n\n// 渲染\nconst render = () => {\n  const dom = <HTMLElement>containerRef.value\n  // 渲染器\n  renderer = UTILS.createRender(dom)\n  // 相机\n  camera = UTILS.createPerspectiveCamera(dom, 1, 1000000)\n  // 灯光\n  createLight()\n  // 控制器\n  controls = UTILS.createControl(camera, renderer)\n  // 右键拖拽\n  // controls.enablePan = false\n  controls.maxPolarAngle = Math.PI * 0.45\n  // 垂直平移\n  controls.screenSpacePanning = false\n\n  // 网格\n  if (isDev) {\n    grid = UTILS.createLayoutGrid()\n    scene.add(grid)\n  }\n\n  if (isDev) {\n    // 辅助坐标器\n    let axesHelper = new THREE.AxesHelper(50)\n    scene.add(axesHelper)\n  }\n\n  initModel()\n  addGui(dom)\n}\n\nonMounted(() => {\n  render()\n  animate()\n  window.addEventListener('resize', windowResize, false)\n})\n\nonBeforeUnmount(() => {\n  // 解绑事件\n  window.addEventListener('resize', windowResize, false)\n  // 停止动画\n  cancelAnimationFrame(__request_animation_frame_id__)\n  // 清除场景（不清除会一直占用缓存）\n  try {\n    scene.clear()\n    renderer.dispose()\n    renderer.forceContextLoss()\n    renderer.content = null\n    let gl = renderer.domElement.getContext('webgl')\n    gl && gl.getExtension('WEBGL_lose_context').loseContext()\n  } catch (e) {\n    console.log(e)\n  }\n})\n</script>\n\n<style></style>\n"],"names":["assetsStore","useAssetsStore","containerRef","ref","scene","THREE.Scene","camera","renderer","controls","ambientLight","background","THREE.Color","createLight","THREE.AmbientLight","add","color","intensity","s","size","near","far","dirLight","THREE.DirectionalLight","position","set","castShadow","shadow","right","left","top","bottom","mapSize","UTILS.createDirectionalLight","windowResize","container","value","width","clientWidth","height","clientHeight","k","aspect","updateProjectionMatrix","setSize","__request_animation_frame_id__","animate","requestAnimationFrame","render","modelAnimate","time","performance","now","geometryMesh","y","Math","sin","rotation","x","z","water","material","uniforms","effectController","reactive","turbidity","rayleigh","mieCoefficient","mieDirectionalG","elevation","azimuth","exposure","pmremGenerator","createWater","waterGeometry","THREE.PlaneGeometry","Water","textureWidth","textureHeight","waterNormals","THREE.TextureLoader","load","oss","texture","wrapS","wrapT","THREE.RepeatWrapping","sunDirection","THREE.Vector3","sunColor","waterColor","distortionScale","fog","PI","sky","createSky","Sky","scale","setScalar","sun","updateSkyAndSun","skyUniforms","phi","THREE.MathUtils","degToRad","theta","setFromSphericalCoords","copy","normalize","environment","fromScene","toneMappingExposure","addGeometry","geometry","THREE.BoxGeometry","THREE.MeshStandardMaterial","roughness","THREE.Mesh","dom","THREE.WebGLRenderer","antialias","setPixelRatio","window","devicePixelRatio","appendChild","domElement","UTILS.createRender","UTILS.createPerspectiveCamera","THREE.PerspectiveCamera","UTILS.createControl","OrbitControls","minDistance","maxPolarAngle","target","screenSpacePanning","toneMapping","THREE.ACESFilmicToneMapping","THREE.PMREMGenerator","gui","GUI","folderSky","addFolder","name","onChange","folderWater","waterUniforms","style","addGui","onMounted","addEventListener","onBeforeUnmount","cancelAnimationFrame","clear","dispose","forceContextLoss","content","gl","getContext","getExtension","loseContext","e","console","log"],"mappings":"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"}