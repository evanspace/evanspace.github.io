var e=Object.defineProperty,t=(t,i,s)=>(((t,i,s)=>{i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s})(t,"symbol"!=typeof i?i+"":i,s),s);import{en as i,dA as s,ek as n,eo as a,ep as o,eq as r,er as l,es as d,et as c,bp as h,bc as u,ba as p,eu as m,bk as f,bd as x,bb as g,dB as b,em as w,e as B,i as v,l as y,o as C,g as P,h as T}from"./vendor-43c1f6dd.js";import{m as I,u as R}from"./scene-resize-ca30cc7f.js";import"./index-67768ca8.js";const M=w,z=()=>M.uint(16777215*Math.random());class j extends I{constructor(e){super(e),t(this,"maxCount",5e4),t(this,"count",5e3),t(this,"collisionCamera"),t(this,"renderTarget"),t(this,"material"),t(this,"positionBuffer"),t(this,"velocityBuffer"),t(this,"ripplePositionBuffer"),t(this,"rippleTimeBuffer"),t(this,"computeParticles"),t(this,"rainParticles"),t(this,"rippleParticles"),t(this,"collisionBox"),t(this,"gui"),this.collisionCamera=this.createCollisionCamera(),this.renderTarget=this.createRenderTarget();const n=new i;n.colorNode=M.positionWorld,this.material=n,this.positionBuffer=this.createBuffer(),this.velocityBuffer=this.createBuffer(),this.ripplePositionBuffer=this.createBuffer(),this.rippleTimeBuffer=this.createBuffer();const a=this.initCompute(),o=this.computeUpdate();this.computeParticles=o().compute(this.maxCount),this.addModel(),this.renderer.computeAsync(a),this.gui=new s,this.addGui()}initRenderer(){const{width:e,height:t,bgColor:i,bgUrl:s,env:o}=this.options,r=new n(this.options.render);if(o&&this.setEnvironment(o),s?this.setBgTexture(s):this.setBgColor(i),this.options.fog.visible){const{color:e,near:t,far:i}=this.options.fog;this.scene.fog=new a(e??this.scene.background,t,i)}return r.setSize(e,t),r.setPixelRatio(window.devicePixelRatio),this.container.appendChild(r.domElement),r}createCollisionCamera(){const e=new o(-50,50,50,-50,.1,50);return e.position.y=50,e.lookAt(0,0,0),e.layers.disableAll(),e.layers.enable(1),e}createRenderTarget(){const e=new r(1024,1024),t=e.texture;return t.type=l,t.magFilter=d,t.minFilter=d,t.generateMipmaps=!1,e}createBuffer(e="vec3"){const t=this.maxCount;return M.storage(new c(t,3),e,t)}initCompute(){return M.Fn((()=>{const e=this.positionBuffer.element(M.instanceIndex),t=this.velocityBuffer.element(M.instanceIndex),i=this.rippleTimeBuffer.element(M.instanceIndex),s=M.hash(M.instanceIndex),n=M.hash(M.instanceIndex.add(z())),a=M.hash(M.instanceIndex.add(z()));e.x=s.mul(100).add(-50),e.y=n.mul(25),e.z=a.mul(100).add(-50),t.y=s.mul(-.04).add(-.2),i.x=1e3}))().compute(this.maxCount)}computeUpdate(){return M.Fn((()=>{const e=e=>e.add(50).div(100),t=this.positionBuffer.element(M.instanceIndex),i=this.velocityBuffer.element(M.instanceIndex),s=this.ripplePositionBuffer.element(M.instanceIndex),n=this.rippleTimeBuffer.element(M.instanceIndex);t.addAssign(i),n.x=n.x.add(M.deltaTime.mul(4));const a=M.texture(this.renderTarget.texture,e(t.xz)).y.add(.05);M.If(t.y.add(-.9).lessThan(a),(()=>{t.y=25,s.xz=t.xz,s.y=a,n.x=1,t.x=M.hash(M.instanceIndex.add(M.time)).mul(100).add(-50),t.z=M.hash(M.instanceIndex.add(M.time.add(z()))).mul(100).add(-50)}));const o=M.texture(this.renderTarget.texture,e(s.xz)).y.add(.05);M.If(s.y.greaterThan(o),(()=>{n.x=1e3}))}))}addModel(){this.createRainDrop(),this.createRainRipple(),this.createCollisionGround(),this.createCollisionModel()}createRainDrop(){const e=new i;e.colorNode=M.uv().distance(M.vec2(.5,0)).oneMinus().mul(3).exp().mul(.1),e.vertexNode=M.billboarding({position:this.positionBuffer.toAttribute()}),e.opacity=.2,e.side=h,e.forceSinglePass=!0,e.depthWrite=!1,e.depthTest=!0,e.transparent=!0;const t=new u(new p(.1,2),e);t.count=this.count,this.rainParticles=t,this.addObject(t)}createRainRipple(){const e=this.rippleTimeBuffer.element(M.instanceIndex).x,t=M.Fn((()=>{const t=M.uv().add(M.vec2(-.5)).length().mul(7),i=e.sub(t);return i.min(1).sub(i.max(1).sub(1))})),s=new i;s.colorNode=t(),s.positionNode=M.positionGeometry.add(this.ripplePositionBuffer.toAttribute()),s.opacityNode=e.mul(.3).oneMinus().max(0).mul(.5),s.side=h,s.forceSinglePass=!0,s.depthWrite=!1,s.depthTest=!0,s.transparent=!0;const n=new p(2.5,2.5);n.rotateX(-Math.PI/2);const a=new p(1,2);a.rotateY(-Math.PI/2);const o=new p(1,2),r=m([n,a,o]),l=new u(r,s);l.count=this.count,this.rippleParticles=l,this.addObject(l)}createCollisionGround(){const e=new p(1e3,1e3);e.rotateX(-Math.PI/2);const t=new u(e,new f({color:328965}));this.addObject(t)}createCollisionModel(){const e=new u(new x(30,1,15),new g({color:3355443}));e.position.y=12,e.scale.x=3.5,e.layers.enable(1),e.castShadow=!0,this.collisionBox=e,this.addObject(e);const t=new u(new b(5,1,128,100),new g({color:3355443}));t.position.set(0,12,15),t.layers.enable(1),this.addObject(t)}addGui(){var e,t,i;const s=this.gui;s.add(null==(e=this.collisionBox)?void 0:e.position,"z",-50,50),s.add(null==(t=this.collisionBox)?void 0:t.scale,"x",.1,4),s.add(this.rainParticles,"count",200,this.maxCount).name("数量").onChange((e=>{this.rippleParticles.count=e})),s.domElement.className+=" gui-wrap",null==(i=this.container.parentNode)||i.appendChild(s.domElement)}animate(){const e=this.renderer;e&&(this.scene.overrideMaterial=this.material,e.setRenderTarget(this.renderTarget),e.render(this.scene,this.collisionCamera),e.compute(this.computeParticles),this.scene.overrideMaterial=null,e.setRenderTarget(null),e.render(this.scene,this.camera))}}const N={class:"three-page"},A=B({__name:"index",setup(e){const t=v(),i={grid:{},render:{antialias:!0,logarithmicDepthBuffer:!1},axes:{visible:!0},ambientLight:{color:1118481},directionalLight:{position:[3,17,17]},camera:{position:[40,8,0]},controls:{maxDistance:50}};let s;return y((()=>{i.container=t.value,s=new j(i),s.run(),R(s).resize()})),(e,i)=>(C(),P("div",N,[T("div",{class:"h-100",ref_key:"containerRef",ref:t},null,512)]))}});export{A as default};
